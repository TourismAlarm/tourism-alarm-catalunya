<!DOCTYPE html>
<html>
<head>
    <title>üî• DIAGN√ìSTICO HEATMAP - Tourism Alarm</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css">
    <style>
        body { margin: 0; font-family: 'Courier New', monospace; background: #000; color: #0f0; }
        #map { height: 60vh; width: 100%; border: 2px solid #0f0; }
        #diagnostico { 
            height: 40vh; overflow-y: auto; padding: 10px; 
            background: #001100; border: 2px solid #0f0; font-size: 12px;
        }
        .success { color: #0f0; }
        .warning { color: #ff0; }
        .error { color: #f00; }
        .info { color: #0af; }
        .header { color: #fff; font-weight: bold; background: #333; padding: 5px; margin: 5px 0; }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="diagnostico">
        <div class="header">üî• DIAGN√ìSTICO AUTOM√ÅTICO HEATMAP TOURISM ALARM üî•</div>
        <div id="logs"></div>
    </div>

    <script>
        const log = (message, type = 'info') => {
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = `${new Date().toLocaleTimeString()}: ${message}`;
            document.getElementById('logs').appendChild(div);
            console.log(`[${type.toUpperCase()}] ${message}`);
        };

        async function diagnosticoCompleto() {
            log('üöÄ INICIANDO DIAGN√ìSTICO AUTOM√ÅTICO DEL HEATMAP', 'header');
            
            // PRUEBA 1: Conectividad API
            log('üì° Probando conectividad con API...', 'info');
            try {
                const response = await fetch('http://localhost:3004/api/municipalities?limit=50');
                const data = await response.json();
                
                if (data.success && data.data && data.data.length > 0) {
                    log(`‚úÖ API FUNCIONA: ${data.data.length} municipios recibidos`, 'success');
                    log(`üìä Fuente de datos: ${data.source}`, 'info');
                    
                    // Analizar diversidad de intensidades
                    const intensidades = data.data.map(m => m.heatmap_intensity || 0);
                    const min = Math.min(...intensidades);
                    const max = Math.max(...intensidades);
                    const avg = intensidades.reduce((a,b) => a+b, 0) / intensidades.length;
                    
                    log(`üé® INTENSIDADES: min=${min.toFixed(3)}, max=${max.toFixed(3)}, promedio=${avg.toFixed(3)}`, 'info');
                    
                    if (max - min < 0.1) {
                        log('‚ö†Ô∏è PROBLEMA: Poca diversidad de intensidades (colores similares)', 'warning');
                    } else {
                        log('‚úÖ Buena diversidad de intensidades (colores variados)', 'success');
                    }
                } else {
                    log('‚ùå API no devuelve datos v√°lidos', 'error');
                    return false;
                }
            } catch (error) {
                log(`‚ùå ERROR API: ${error.message}`, 'error');
                return false;
            }

            // PRUEBA 2: Inicializaci√≥n del mapa
            log('üó∫Ô∏è Inicializando mapa base...', 'info');
            try {
                const map = L.map('map').setView([41.5868, 1.8174], 8);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: 'OpenStreetMap'
                }).addTo(map);
                log('‚úÖ Mapa base inicializado correctamente', 'success');

                // PRUEBA 3: Generar heatmap con datos reales
                log('üî• Generando heatmap con datos reales...', 'info');
                const fullResponse = await fetch('http://localhost:3004/api/municipalities?limit=947');
                const fullData = await fullResponse.json();
                
                if (fullData.success && fullData.data) {
                    const heatmapPoints = [];
                    let municipiosConCoords = 0;
                    let municipiosSinCoords = 0;
                    
                    fullData.data.forEach(municipality => {
                        if (municipality.lat && municipality.lng && 
                            !isNaN(municipality.lat) && !isNaN(municipality.lng)) {
                            
                            municipiosConCoords++;
                            
                            // Simular algoritmo de intensidad mejorado
                            let intensity = 0.3; // Base
                            
                            // Factor ratio turistas
                            if (municipality.ratio_turistes > 50) intensity = 0.9;
                            else if (municipality.ratio_turistes > 20) intensity = 0.75;
                            else if (municipality.ratio_turistes > 5) intensity = 0.6;
                            else if (municipality.ratio_turistes > 2) intensity = 0.45;
                            
                            // Factor visitantes
                            const visitors = municipality.visitants_anuals || 0;
                            if (visitors > 5000000) intensity = Math.min(1.0, intensity + 0.3);
                            else if (visitors > 2000000) intensity = Math.min(1.0, intensity + 0.2);
                            else if (visitors > 500000) intensity = Math.min(1.0, intensity + 0.1);
                            
                            // Variaci√≥n aleatoria
                            intensity += (Math.random() - 0.5) * 0.2;
                            intensity = Math.max(0.1, Math.min(1.0, intensity));
                            
                            // Crear m√∫ltiples puntos seg√∫n superficie
                            const superficie = municipality.superficie_km2 || 10;
                            const numPoints = Math.max(3, Math.floor(Math.sqrt(superficie) * 2));
                            const variation = Math.min(0.08, Math.max(0.005, Math.sqrt(superficie) * 0.008));
                            
                            for (let i = 0; i < numPoints; i++) {
                                const pointLat = municipality.lat + (Math.random() - 0.5) * variation;
                                const pointLng = municipality.lng + (Math.random() - 0.5) * variation;
                                const pointIntensity = intensity * (0.8 + Math.random() * 0.4);
                                
                                heatmapPoints.push([pointLat, pointLng, pointIntensity]);
                            }
                        } else {
                            municipiosSinCoords++;
                        }
                    });
                    
                    log(`üìä ESTAD√çSTICAS: ${municipiosConCoords} municipios con coordenadas, ${municipiosSinCoords} sin coordenadas`, 'info');
                    log(`üî• Puntos heatmap generados: ${heatmapPoints.length}`, 'info');
                    
                    if (heatmapPoints.length > 0) {
                        // Crear heatmap
                        const heatLayer = L.heatLayer(heatmapPoints, {
                            radius: 25,
                            blur: 15,
                            maxZoom: 18,
                            gradient: {
                                0.0: 'rgba(0,0,255,0)',
                                0.2: '#0000FF',
                                0.4: '#00FF00', 
                                0.6: '#FFFF00',
                                0.8: '#FF8000',
                                1.0: '#FF0000'
                            }
                        }).addTo(map);
                        
                        // Analizar distribuci√≥n de intensidades
                        const intensidades = heatmapPoints.map(p => p[2]);
                        const stats = {
                            min: Math.min(...intensidades),
                            max: Math.max(...intensidades),
                            avg: intensidades.reduce((a,b) => a+b, 0) / intensidades.length
                        };
                        
                        log(`üé® AN√ÅLISIS DE COLORES:`, 'header');
                        log(`   Intensidad m√≠nima: ${stats.min.toFixed(3)} (azul/verde)`, 'info');
                        log(`   Intensidad m√°xima: ${stats.max.toFixed(3)} (naranja/rojo)`, 'info');
                        log(`   Intensidad promedio: ${stats.avg.toFixed(3)}`, 'info');
                        
                        // Distribuci√≥n por rangos de color
                        const rangos = {
                            azul: intensidades.filter(i => i <= 0.2).length,
                            verde: intensidades.filter(i => i > 0.2 && i <= 0.4).length,
                            amarillo: intensidades.filter(i => i > 0.4 && i <= 0.6).length,
                            naranja: intensidades.filter(i => i > 0.6 && i <= 0.8).length,
                            rojo: intensidades.filter(i => i > 0.8).length
                        };
                        
                        log(`üìà DISTRIBUCI√ìN DE COLORES:`, 'header');
                        log(`   üîµ Azul (0.0-0.2): ${rangos.azul} puntos`, 'info');
                        log(`   üü¢ Verde (0.2-0.4): ${rangos.verde} puntos`, 'info');
                        log(`   üü° Amarillo (0.4-0.6): ${rangos.amarillo} puntos`, 'info');
                        log(`   üü† Naranja (0.6-0.8): ${rangos.naranja} puntos`, 'info');
                        log(`   üî¥ Rojo (0.8-1.0): ${rangos.rojo} puntos`, 'info');
                        
                        if (rangos.azul + rangos.verde > heatmapPoints.length * 0.8) {
                            log('‚ö†Ô∏è ADVERTENCIA: Predominan colores fr√≠os (poca intensidad)', 'warning');
                        } else if (rangos.rojo + rangos.naranja > heatmapPoints.length * 0.3) {
                            log('‚úÖ Buena distribuci√≥n con colores c√°lidos (alta intensidad)', 'success');
                        } else {
                            log('‚úÖ Distribuci√≥n equilibrada de colores', 'success');
                        }
                        
                        // PRUEBA 4: Funcionalidad zoom
                        log('üéØ Probando funcionalidad de zoom...', 'info');
                        map.on('zoomend', () => {
                            const currentZoom = map.getZoom();
                            if (currentZoom <= 6) {
                                log(`üôà Zoom ${currentZoom}: Heatmap deber√≠a estar OCULTO`, 'warning');
                            } else {
                                log(`üëÅÔ∏è Zoom ${currentZoom}: Heatmap deber√≠a estar VISIBLE`, 'success');
                            }
                        });
                        
                        log('‚úÖ HEATMAP CREADO EXITOSAMENTE', 'success');
                        log('üéÆ Prueba zoom in/out para verificar ocultaci√≥n autom√°tica', 'info');
                        
                    } else {
                        log('‚ùå No se generaron puntos para el heatmap', 'error');
                    }
                }
                
            } catch (error) {
                log(`‚ùå ERROR generando heatmap: ${error.message}`, 'error');
            }
            
            log('üèÅ DIAGN√ìSTICO COMPLETADO', 'header');
        }

        // Ejecutar diagn√≥stico cuando cargue la p√°gina
        document.addEventListener('DOMContentLoaded', diagnosticoCompleto);
    </script>
</body>
</html>